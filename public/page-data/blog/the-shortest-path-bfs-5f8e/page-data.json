{"componentChunkName":"component---src-templates-blog-js","path":"/blog/the-shortest-path-bfs-5f8e","result":{"data":{"devArticles":{"article":{"tags":["javascript","bfs","dfs"],"slug":"the-shortest-path-bfs-5f8e","title":"The shortest path - BFS","cover_image":"https://res.cloudinary.com/practicaldev/image/fetch/s--E3WmJtum--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/euh5r99iximd801d0zy6.png","description":"In a previous blog, I talked about 2 types of search algorithms, for the tree data structure, which w...","published_at":"Sep 24 2020","edited_at":null,"positive_reactions_count":0,"comments_count":0,"body_html":"<p>In a <a href=\"https://dev.to/foqc/plotting-a-binary-tree-in-javascript-47hc\">previous blog</a>, I talked about 2 types of search algorithms, for the tree data structure, which were, the <strong>Depth First Search - DFS</strong> and <strong>Breath First Search DFS</strong>, and I mentioned that the The most <strong>efficient algorithm to find the shortest path is BFS</strong>, this algorithm starts from the root and goes through each node by levels instead of branches as DFS does, <strong>using a queue</strong> to temporarily store the nodes. On the other hand, with the DFS algorithm, one must go completely branch by branch, so it would be necessary to store each solution found and at the end obtain the solution that has the shortest path.</p>\n\n<h2>\n  <a name=\"the-problem\" href=\"#the-problem\" class=\"anchor\">\n  </a>\n  The problem\n</h2>\n\n<p><em>There is a list of words and that given the start and end word, the shortest path must be found, starting from the beginning to the end, the only 2 rules are, while looking for the shortest path, only one letter it can be changed at the same time and the intermediate words that are generated must exist in the word list.</em></p>\n\n<p><strong>Note:</strong> This blog is a JavaScript version of <a href=\"https://javabypatel.blogspot.com/2017/05/bfs-vs-dfs-with-example-in-java.html\">JavaByPatel blog</a>.</p>\n\n<p>A simple example is shown below:<br>\n<strong>start word</strong> = CAT<br>\n<strong>final palatra</strong> = DOG<br>\n<strong>list</strong> = CAT, BAT, COT, COG, COW, RAT, BUT, CUT, DOG, WEB</p>\n\n<p>A path could be the following, <strong>CAT - RAT - BAT - BUT - CUT - COT - COG - DOG,</strong> however the shortest path is, <strong>CAT - COT - COG - DOG</strong>, BFS algorithm allows go through the shortest path, below is the implementation of this algorithm with its respective explanation.</p>\n\n<p>First, to determine that in a word, only one letter has been changed at a time, the following function is implemented.<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight javascript\"><code><span class=\"kd\">function</span> <span class=\"nx\">differByOne</span><span class=\"p\">(</span><span class=\"nx\">word</span><span class=\"p\">,</span> <span class=\"nx\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">word</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">!==</span> <span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">diffCount</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"nx\">i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">word</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">;</span> <span class=\"nx\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">charAt</span><span class=\"p\">(</span><span class=\"nx\">i</span><span class=\"p\">)</span> <span class=\"o\">!==</span> <span class=\"nx\">word</span><span class=\"p\">.</span><span class=\"nx\">charAt</span><span class=\"p\">(</span><span class=\"nx\">i</span><span class=\"p\">))</span>\n            <span class=\"nx\">diffCount</span><span class=\"o\">++</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">diffCount</span> <span class=\"o\">===</span> <span class=\"mi\">1</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n\n\n<p>Next, BFS is implemented, to find the shortest path.<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight javascript\"><code><span class=\"kd\">function</span> <span class=\"nx\">checkWords</span><span class=\"p\">(</span><span class=\"nx\">words</span><span class=\"p\">,</span> <span class=\"nx\">start</span><span class=\"p\">,</span> <span class=\"nx\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">words</span><span class=\"p\">.</span><span class=\"nx\">has</span><span class=\"p\">(</span><span class=\"nx\">start</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"nx\">words</span><span class=\"p\">.</span><span class=\"nx\">has</span><span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"kc\">null</span>\n\n    <span class=\"kd\">const</span> <span class=\"nx\">queue</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"kd\">const</span> <span class=\"nx\">path</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">start</span><span class=\"p\">)</span>\n    <span class=\"nx\">queue</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">path</span><span class=\"p\">)</span>\n    <span class=\"nx\">words</span><span class=\"p\">.</span><span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"nx\">start</span><span class=\"p\">)</span>\n\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nx\">queue</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kd\">const</span> <span class=\"nx\">lastPath</span> <span class=\"o\">=</span> <span class=\"nx\">queue</span><span class=\"p\">.</span><span class=\"nx\">shift</span><span class=\"p\">()</span>\n        <span class=\"kd\">const</span> <span class=\"nx\">lastWord</span> <span class=\"o\">=</span> <span class=\"nx\">lastPath</span><span class=\"p\">[</span><span class=\"nx\">lastPath</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">target</span> <span class=\"o\">==</span> <span class=\"nx\">lastWord</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nx\">lastPath</span>\n\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">item</span> <span class=\"k\">of</span> <span class=\"nx\">words</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">differByOne</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">,</span> <span class=\"nx\">lastWord</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                <span class=\"kd\">const</span> <span class=\"nx\">newPath</span> <span class=\"o\">=</span> <span class=\"p\">[...</span><span class=\"nx\">lastPath</span><span class=\"p\">]</span>\n                <span class=\"nx\">newPath</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">)</span>\n                <span class=\"nx\">queue</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">newtPath</span><span class=\"p\">)</span>\n                <span class=\"nx\">words</span><span class=\"p\">.</span><span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span>\n         <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"kc\">null</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n\n\n\n<ul>\n<li>The <strong>checkWords</strong> function receives 3 parameters, the first is the list of words which is a data type <strong>Set</strong>, the start and target word.</li>\n<li>Check if the word list <strong>does NOT contain</strong> the initial or target word, to immediately return null, <strong>(!Words.has(start) ||! Words.has(target))</strong>.</li>\n<li>Declare an array, which <strong>will be used as a queue</strong> to store the shortest path.</li>\n<li>Declare an <strong>array called path</strong>, to store the selected words.</li>\n<li>\n<strong>Add to the path</strong>, the start word, <strong>path.push(start)</strong>.</li>\n<li>Add the <strong>new path to the queue</strong>.</li>\n<li>Removes the first selected word <strong>words.delete(start)</strong> from the word list.</li>\n<li>As long as <strong>there is data in the queue</strong>, while (queue.length), the following is done.</li>\n<li>Removes the first path (word list) from the queue and returns it, to the <strong>lastPath constant</strong>.</li>\n<li>The last selected word is obtained from the word list obtained in the previous step, <strong>const lastWord = lastPath [lastPath.length - 1]</strong>.</li>\n<li>If the last <strong>selected word is the final word</strong> that is being searched, it returns the list of words obtained (shortest path) <strong>if(target == lastWord) return lastPath</strong>, in case it is not fulfilled, continue with the following instructions.</li>\n<li>The following is done for every word in the word list.</li>\n<li>Verify that the current word (item) in the word list only has a different letter with respect to the last selected word (lastWord), <strong>differByOne(item, lastWord)</strong>.</li>\n<li>In case the previous condition is met, create a new list (new path) with the words of the last path found (list of words - lastPath) <strong>const newPath = [... lastPath]</strong>.</li>\n<li>To the new path, the word that meets the condition explained in previous item, <strong>newPath.push(item)</strong>, is added.</li>\n<li>The new path is added to the queue, <strong>queue.push(newtPath)</strong>.</li>\n<li>Delete the selected word from the word list, <strong>words.delete(item)</strong>.</li>\n<li>In case the final word is not found during the repetitive cycle, <strong>null is returned</strong>.</li>\n</ul>\n\n<p>Done!, it's time to test the functionality of the algorithm explained above, as shown below.<br>\n</p>\n\n<div class=\"highlight\"><pre class=\"highlight javascript\"><code><span class=\"kd\">const</span> <span class=\"nx\">words</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Set</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">BUT</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">CUT</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">RAT</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">BAT</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">WEB</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">CAT</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">COT</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">COG</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">COW</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">DOG</span><span class=\"dl\">'</span><span class=\"p\">])</span>\n<span class=\"kd\">const</span> <span class=\"nx\">start</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">CAT</span><span class=\"dl\">'</span>\n<span class=\"kd\">const</span> <span class=\"nx\">target</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">DOG</span><span class=\"dl\">'</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">checkWords</span><span class=\"p\">(</span><span class=\"nx\">words</span><span class=\"p\">,</span> <span class=\"nx\">start</span><span class=\"p\">,</span> <span class=\"nx\">target</span><span class=\"p\">))</span>\n\n<span class=\"c1\">// output</span>\n<span class=\"c1\">// [\"CAT\", \"COT\", \"COG\", \"DOG\"]</span>\n</code></pre></div>\n\n\n\n<p>The previous code calls the <strong>checkWords</strong> function, the list of words is sent in a data structure of <strong>type Set</strong>, the initial and target words to be searched, the result is printed in the console. <strong>The result will be the shortest path found from the starting word to the end.</strong></p>\n\n<p>The source code is on <a href=\"https://github.com/foqc/shortest-path\">GitHub</a>.</p>\n\n<p>Was it useful? Show your support and share it.</p>\n\n<p>Stay safe and thank you so much for reading!</p>\n\n","url":"https://dev.to/foqc/the-shortest-path-bfs-5f8e"}}},"pageContext":{"id":"the-shortest-path-bfs-5f8e"}}}